# 图结构
## 概念
> 图是由顶点的有穷非空集合和顶点之间边的集合组成，通常表示为G(V,E)，其中G表示一个图，V是图G中顶点的集合，E是图G中边的集合

## 存储
### 邻接矩阵
- 便于判断两个顶点之间是否有边， 即根据A[i][j] = 0或1来判断。
- 便于计算各个顶点的度。对千无向图，邻接矩阵第凶于元素之和就是顶点l的度;对于有向图，第i行元素之和就是顶点i的出度，第i列元素之和就是顶点i的入度。
- 空间复杂度O(n^2), 适合存储稠密图，不适合存储稀疏图

### 邻接表
- 便于统计边的数目，按顶点表顺序扫描所有边表可得到边的数目，时间复杂度O(n+e)
- 邻接表或逆邻接表表示的空间复杂度是O(n+e),适合表示稀疏图
- 不便于判断顶点间是否有边，不便计算有向图各顶点的度

### 邻接矩阵和邻接表的关系
联系
- 邻接表中每个链表对应于邻接矩阵中的一行
- 链表中结点个数等于一行中非零元素个数
区别
- 对于任一确定的无向图,邻接矩阵是唯一的(行列号与顶点编号一致),但邻接表不唯一(链接次序与顶点编号无关)
- 邻接矩阵的空间复杂度O(n^2),而邻接表的空间复杂度为O(n+e)

### 十字链表
- 适合存储有向图，将出度和入度都存在一个节点上，方便查询

### 邻接多重表

### DFS深度优先遍历
1. 一条路线走到底,然后检查是否每个结点都被访问过,如果都访问过,则后退一步.重复以上步骤.
2. 解题思路: 使用一个visited数组标记结点是否被访问过.然后借用递归或自己写的栈实现
![](https://mubu.com/document_image/8df15358-cdab-4c62-bb6c-546a950088df-2746950.jpg)
![](https://mubu.com/document_image/317f3dec-40e5-481e-8a40-fbd767943f17-2746950.jpg)
当使用邻接矩阵表示图的时候，DFS时间复杂度复杂度O(n^2)，n为图顶点数
当使用邻接表存储图的时候，DFS时间复杂度为O(n+e),n为图顶点数,e为图中边数

### BFS广度优先遍历
类似树的层序遍历
1. 一层一层的遍历.遍历每一层结点
1. 解题思路: 1.使用一个循环队列,2再使用一个visited数组标记结点是否被访问过.3访问一个结点加入队列.直到队列为空和visited也都为1
![](https://mubu.com/document_image/7f9a0b4d-2e93-475e-b11b-41baac8855fb-2746950.jpg)
![](https://mubu.com/document_image/5e9106be-c902-4ec3-b887-5b70ce751d09-2746950.jpg)
![](https://mubu.com/document_image/1d5d6197-f1bb-4b9e-8c93-8f3d55133977-2746950.jpg)
当使用邻接矩阵表示图的时候，BFS时间复杂度复杂度O(n^2)，n为图顶点数
当使用邻接表存储图的时候，BFS时间复杂度为O(n+e),n为图顶点数,e为图中边数
